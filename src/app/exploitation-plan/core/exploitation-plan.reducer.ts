import {
  AddExploitationPlanTaskSuccessAction,
  ExploitationPlanActions,
  ExploitationPlanActionTypes,
  InitExploitationPlanSuccessAction,
  RemoveExploitationPlanTaskSuccessAction,
  UpdateExploitationPlanStepAction,
  OrderExploitationPlanTasksAction,
  SetExploitationPlanStepCollapseAction,
  ClearExploitationPlanStepCollapseAction,
  InitCompareAction,
  StopCompareExploitationPlanAction,
  InitCompareSuccessAction
} from './exploitation-plan.actions';
import { ExploitationPlan } from './models/exploitation-plan.model';
import { ExploitationPlanStep } from './models/exploitation-plan-step.model';
import { ExploitationPlanTask } from './models/exploitation-plan-task.model';

/**
 * An interface to represent Exploitation Plan object entry
 */
export interface ExploitationPlanEntry {
  [exploitationPlanId: string]: ExploitationPlan;
}

/**
 * The Exploitation Plan State
 */
export interface ExploitationPlanState {
  exploitationPlan: ExploitationPlanEntry;
  loaded: boolean;
  processing: boolean;
  moving: boolean;
  collapsed: any;
  compareMode: boolean;
}

const initialState: ExploitationPlanState = {
  exploitationPlan: null,
  loaded: false,
  processing: false,
  moving: false,
  collapsed: {},
  compareMode: false
};

/**
 * The Exploitation Plan Reducer
 *
 * @param state
 *    the current state
 * @param action
 *    the action to perform on the state
 * @return ExploitationPlanState
 *    the new state
 */
export function exploitationPlanReducer(state = initialState, action: ExploitationPlanActions): ExploitationPlanState {
  switch (action.type) {

    case ExploitationPlanActionTypes.ADD_EXPLOITATION_PLAN_TASK:
    case ExploitationPlanActionTypes.GENERATE_EXPLOITATION_PLAN_TASK:
    case ExploitationPlanActionTypes.INIT_EXPLOITATION_PLAN:
    case ExploitationPlanActionTypes.REMOVE_EXPLOITATION_PLAN_TASK: {
      return Object.assign({}, state, {
        processing: true
      });
    }

    case ExploitationPlanActionTypes.ADD_EXPLOITATION_PLAN_TASK_SUCCESS: {
      return addExploitationPlanTaskToExploitationPlanStep(state, action as AddExploitationPlanTaskSuccessAction);
    }

    case ExploitationPlanActionTypes.INIT_EXPLOITATION_PLAN_SUCCESS: {
      return initExploitationPlan(state, action as InitExploitationPlanSuccessAction);
    }



    case ExploitationPlanActionTypes.INIT_COMPARE_EXPLOITATION_PLAN: {
      return initCompare(state, action as InitCompareAction);
    }


    case ExploitationPlanActionTypes.STOP_COMPARE_EXPLOITATION_PLAN: {
      return stopCompare(state, action as StopCompareExploitationPlanAction);
    }


    case ExploitationPlanActionTypes.INIT_COMPARE_EXPLOITATION_PLAN_SUCCESS: {
      return replaceExploitationPlanSteps(state, action as InitCompareSuccessAction);
    }

    case ExploitationPlanActionTypes.ADD_EXPLOITATION_PLAN_TASK_ERROR:
    case ExploitationPlanActionTypes.GENERATE_EXPLOITATION_PLAN_TASK_ERROR:
    case ExploitationPlanActionTypes.INIT_EXPLOITATION_PLAN_ERROR:
    case ExploitationPlanActionTypes.REMOVE_EXPLOITATION_PLAN_TASK_ERROR: {
      return Object.assign({}, state, {
        processing: false
      });
    }

    case ExploitationPlanActionTypes.ORDER_EXPLOITATION_PLAN_TASK: {
      return setExploitationPlanTasks(
        state,
        (action as OrderExploitationPlanTasksAction).payload.exploitationPlanId,
        (action as OrderExploitationPlanTasksAction).payload.stepId,
        (action as OrderExploitationPlanTasksAction).payload.currentTasks,
        (action as OrderExploitationPlanTasksAction).payload.previousTasks,
      );
    }


    case ExploitationPlanActionTypes.SET_EXPLOITATION_PLAN_STEP_COLLAPSE: {
      return setExploitationPlanCollapse(
        state,
        (action as SetExploitationPlanStepCollapseAction).payload.exploitationPlanId,
        (action as SetExploitationPlanStepCollapseAction).payload.exploitationPlanStepId,
        (action as SetExploitationPlanStepCollapseAction).payload.value,
      );
    }

    case ExploitationPlanActionTypes.CLEAR_EXPLOITATION_PLAN_STEP_COLLAPSE: {
      return clearExploitationPlanCollapse(
        state
      );
    }

    case ExploitationPlanActionTypes.REMOVE_EXPLOITATION_PLAN_TASK_SUCCESS: {
      return RemoveExploitationPlanTaskFromExploitationPlanStep(state, action as RemoveExploitationPlanTaskSuccessAction);
    }

    case ExploitationPlanActionTypes.UPDATE_EXPLOITATION_PLAN_STEP: {
      return UpdateExploitationPlanTask(state, action as UpdateExploitationPlanStepAction);
    }

    default: {
      return state;
    }
  }
}

/**
 * Init a impact pathway object.
 *
 * @param state
 *    the current state
 * @param action
 *    an InitExploitationPlanSuccessAction
 * @return ExploitationPlanState
 *    the new state.
 */
function addExploitationPlanTaskToExploitationPlanStep(state: ExploitationPlanState, action: AddExploitationPlanTaskSuccessAction): ExploitationPlanState {
  const newState = Object.assign({}, state);
  const step: ExploitationPlanStep = newState.exploitationPlan[action.payload.exploitationPlanId].getStep(action.payload.stepId);
  const stepIndex: number = newState.exploitationPlan[action.payload.exploitationPlanId].getStepIndex(action.payload.stepId);
  const newStep = Object.assign(new ExploitationPlanStep(), step, {
    tasks: [...step.tasks, action.payload.task]
  });
  const newExploitationPlan = Object.assign(new ExploitationPlan(), state.exploitationPlan[action.payload.exploitationPlanId], {
    steps: newState.exploitationPlan[action.payload.exploitationPlanId].steps.map((stepEntry, index) => {
      return (index === stepIndex) ? newStep : stepEntry;
    })
  });
  return Object.assign({}, state, {
    exploitationPlan: Object.assign({}, state.exploitationPlan, {
      [action.payload.exploitationPlanId]: newExploitationPlan
    }),
    processing: false
  });
}

/**
 * Init a impact pathway object.
 *
 * @param state
 *    the current state
 * @param action
 *    an InitExploitationPlanSuccessAction
 * @return ExploitationPlanState
 *    the new state.
 */
function initExploitationPlan(state: ExploitationPlanState, action: InitExploitationPlanSuccessAction): ExploitationPlanState {
  return Object.assign({}, state, {
    exploitationPlan: Object.assign({}, state.exploitationPlan, {
      [action.payload.id]: action.payload.exploitationPlanObj
    }),
    processing: false,
    loaded: true
  });
}


/**
 * Remove task from step.
 *
 * @param state
 *    the current state
 * @param action
 *    an RemoveExploitationPlanTaskSuccessAction
 * @return ExploitationPlanState
 *    the new state.
 */
function RemoveExploitationPlanTaskFromExploitationPlanStep(state: ExploitationPlanState, action: RemoveExploitationPlanTaskSuccessAction): ExploitationPlanState {
  const newState = Object.assign({}, state);
  const step: ExploitationPlanStep = newState.exploitationPlan[action.payload.exploitationPlanId].getStep(action.payload.parentId);
  const stepIndex: number = newState.exploitationPlan[action.payload.exploitationPlanId].getStepIndex(action.payload.parentId);
  const newStep = Object.assign(new ExploitationPlanStep(), step, {
    tasks: [...step.tasks]
  });
  newStep.removeTask(action.payload.taskId);
  const newExploitationPlan = Object.assign(new ExploitationPlan(), state.exploitationPlan[action.payload.exploitationPlanId], {
    steps: newState.exploitationPlan[action.payload.exploitationPlanId].steps.map((stepEntry, index) => {
      return (index === stepIndex) ? newStep : stepEntry;
    })
  });
  return Object.assign({}, state, {
    exploitationPlan: Object.assign({}, state.exploitationPlan, {
      [action.payload.exploitationPlanId]: newExploitationPlan
    }),
    processing: false
  });
}

/**
 * Update an exploitation-plan step object.
 *
 * @param state
 *    the current state
 * @param action
 *    an UpdateExploitationPlanStepAction
 * @return ExploitationPlanState
 *    the new state.
 */
function UpdateExploitationPlanTask(state: ExploitationPlanState, action: UpdateExploitationPlanStepAction): ExploitationPlanState {
  const newState = Object.assign({}, state);
  const stepIndex: number = newState.exploitationPlan[action.payload.exploitationPlanId].getStepIndex(action.payload.exploitationPlanStep.id);

  const newExploitationPlan = Object.assign(new ExploitationPlan(), state.exploitationPlan[action.payload.exploitationPlanId], {
    steps: newState.exploitationPlan[action.payload.exploitationPlanId].steps.map((stepEntry, index) => {
      return (index === stepIndex) ? action.payload.exploitationPlanStep : stepEntry;
    })
  });
  return Object.assign({}, state, {
    exploitationPlan: Object.assign({}, state.exploitationPlan, {
      [action.payload.exploitationPlanId]: newExploitationPlan
    }),
    processing: false
  });
}



/**
 * Order task list of a step
 *
 * @param state
 *    the current state
 * @param exploitationPlanId
 *    the exploitationPlan's Id
 * @param stepId
 *    the ExploitationPlan step's Id
 * @param currentTasks
 *    the ExploitationPlan task list to order
 * @param previousTasks
 *    the ExploitationPlan previous task list
 * @return ExploitationPlanState
 *    the new state.
 */
function setExploitationPlanTasks(
  state: ExploitationPlanState,
  exploitationPlanId: string,
  stepId: string,
  currentTasks: ExploitationPlanTask[],
  previousTasks: ExploitationPlanTask[],
) {
  const newState = Object.assign({}, state);
  const step: ExploitationPlanStep = newState.exploitationPlan[exploitationPlanId].getStep(stepId);
  const stepIndex: number = newState.exploitationPlan[exploitationPlanId].getStepIndex(stepId);
  const newStep = Object.assign(new ExploitationPlanStep(), step, {
    tasks: [...currentTasks]
  });
  const newExploitationPlan = Object.assign(new ExploitationPlan(), state[exploitationPlanId], {
    id: exploitationPlanId,
    steps: newState.exploitationPlan[exploitationPlanId].steps.map((stepEntry, index) => {
      return (index === stepIndex) ? newStep : stepEntry;
    })
  });

  return Object.assign({}, state, {
    exploitationPlan: Object.assign({}, state.exploitationPlan, {
      [exploitationPlanId]: newExploitationPlan
    })
  }) as ExploitationPlanState;
}

/**
 * Set the step collapsed value
 *
 * @param state
 *    the current state
 * @param exploitationPlanId
 *    the exploitationPlan's Id
 * @param stepId
 *    the ExploitationPlan step's Id
 * @param value
 *    the value of collapsed
 * @return ExploitationPlanState
 *    the new state.
 */
function setExploitationPlanCollapse(
  state: ExploitationPlanState,
  exploitationPlanId: string,
  exploitationPlanStepId: string,
  value: boolean
) {
  const newState = Object.assign({}, state);
  let collapsed = Object.assign({}, state.collapsed);

  if (!collapsed[exploitationPlanId]) {
    collapsed[exploitationPlanId] = {};
  }

  const newCollapsedExplotationPlan = Object.assign({}, collapsed[exploitationPlanId], {
    [exploitationPlanStepId]: value
  });

  collapsed = Object.assign({}, collapsed, { [exploitationPlanId]: newCollapsedExplotationPlan });

  return Object.assign({}, state, { collapsed: collapsed }) as ExploitationPlanState;
}


/**
 * Clear the step collapsable
 *
 * @param state
 *    the current state
 * @return ExploitationPlanState
 *    the new state.
 */
function clearExploitationPlanCollapse(
  state: ExploitationPlanState,
) {
  return Object.assign({}, state, { collapsed: {} }) as ExploitationPlanState;
}


/**
 * Init state for comparing.
 *
 * @param state
 *    the current state
 * @param action
 *    an InitCompareAction
 * @return ExploitationPlanState
 *    the new state.
 */
function initCompare(state: ExploitationPlanState, action: InitCompareAction) {
  return Object.assign({}, state, {
    compareExploitationPlanId: action.payload.compareExploitationPlanId,
    compareMode: true,
    loaded:false
  });
}

/**
 * Stop state for comparing.
 *
 * @param state
 *    the current state
 * @param action
 *    an InitCompareAction
 * @return ExploitationPlanState
 *    the new state.
 */
function stopCompare(state: ExploitationPlanState, action: StopCompareExploitationPlanAction) {
  return Object.assign({}, state, {
    compareExploitationPlanId: null,
    compareMode: false,
  });
}

/**
 * replace impact pathway steps.
 *
 * @param state
 *    the current state
 * @param action
 *    an InitCompareAction
 * @return ExploitationPlanState
 *    the new state.
 */
function replaceExploitationPlanSteps(state: ExploitationPlanState, action: InitCompareSuccessAction) {

  const exploitationPlan = state.exploitationPlan;

  return Object.assign({}, state, { loaded: true }, {
    exploitationPlan: Object.assign({}, exploitationPlan, {
      [action.payload.exploitationPlanId]: Object.assign(new ExploitationPlan(), exploitationPlan[action.payload.exploitationPlanId], { steps: action.payload.steps })
    })
  });
}

