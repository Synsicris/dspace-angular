import { Injectable } from '@angular/core';

import { combineLatest as combineLatestObservable, Observable } from 'rxjs';
import { distinctUntilChanged, filter, map, take, tap } from 'rxjs/operators';
import { select, Store } from '@ngrx/store';

import { isNotEmpty } from '../../shared/empty.util';
import { AppState } from '../../app.reducer';
import {
  exploitationPlanByIDSelector,
  isExploitationPlanLoadedSelector,
  isExploitationPlanProcessingSelector,
  exploitationPlanStepByIDSelector,
  exploitationPlanStateSelector
} from './selectors';
import { ExploitationPlan } from './models/exploitation-plan.model';
import { ExploitationPlanStep } from './models/exploitation-plan-step.model';
import { ExploitationPlanTask } from './models/exploitation-plan-task.model';
import {
  AddExploitationPlanTaskAction,
  GenerateExploitationPlanTaskAction,
  PatchExploitationPlanStepMetadataAction,
  RemoveExploitationPlanTaskAction,
  UpdateExploitationPlanStepAction,
  OrderExploitationPlanTasksAction
} from './exploitation-plan.actions';
import { MetadataMap } from '../../core/shared/metadata.models';

@Injectable()
export class ExploitationPlanStateService {

  constructor(private store: Store<AppState>) {
  }

  dispatchAddExploitationPlanTaskAction(
    exploitationPlanId: string,
    stepId: string,
    taskId: string
  ) {
    this.store.dispatch(new AddExploitationPlanTaskAction(
      exploitationPlanId,
      stepId,
      taskId)
    );
  }

  dispatchGenerateExploitationPlanTask(
    projectId: string,
    exploitationPlanId: string,
    stepId: string,
    type: string,
    metadataMap: MetadataMap
  ) {
    this.store.dispatch(new GenerateExploitationPlanTaskAction(
      projectId,
      exploitationPlanId,
      stepId,
      type,
      metadataMap));
  }

  dispatchPatchStepMetadata(
    exploitationPlanId: string,
    stepId: string,
    step: ExploitationPlanStep,
    metadata: string,
    metadataIndex: number,
    value: any
  ) {
    this.store.dispatch(new PatchExploitationPlanStepMetadataAction(
      exploitationPlanId,
      stepId,
      step,
      metadata,
      metadataIndex,
      value
    ));
  }

  dispatchUpdateExploitationPlanStep(exploitationPlanId: string, exploitationPlanStep: ExploitationPlanStep) {
    this.store.dispatch(new UpdateExploitationPlanStepAction(exploitationPlanId, exploitationPlanStep));
  }

  /**
   * Return array of ExploitationPlanStep
   * @param exploitationPlanId
   */
  getExploitationPlanStep(exploitationPlanId: string): Observable<ExploitationPlanStep[]> {
    return this.store.pipe(
      select(exploitationPlanByIDSelector(exploitationPlanId)),
      map((entry: ExploitationPlan) => entry.steps)
    );
  }

  getExploitationPlanTasksByParentId(
    exploitationPlanId: string,
    exploitationPlanIdId: string
  ): Observable<ExploitationPlanTask[]> {
    return this.store.pipe(
      select(exploitationPlanByIDSelector(exploitationPlanId)),
      filter((exploitationPlan: ExploitationPlan) => isNotEmpty(exploitationPlan)),
      map((exploitationPlan: ExploitationPlan) => {
        return exploitationPlan.getStep(exploitationPlanIdId).tasks;
      })
    );
  }

  /**
   * Check whether the state for a give exploitation plan has been loaded
   * @param exploitationPlanId
   */
  isExploitationPlanLoadedById(exploitationPlanId: string): Observable<boolean> {
    const isLoaded$: Observable<boolean> = this.store.pipe(
      select(isExploitationPlanLoadedSelector)
    );

    const exploitationPlan$: Observable<ExploitationPlan> = this.store.pipe(
      select(exploitationPlanByIDSelector(exploitationPlanId))
    );

    return combineLatestObservable([isLoaded$, exploitationPlan$]).pipe(
      map(([isLoaded, exploitationPlan]) => isLoaded && isNotEmpty(exploitationPlan)),
      take(1)
    );
  }

  isExploitationPlanLoaded(): Observable<boolean> {
    return this.store.pipe(
      select(isExploitationPlanLoadedSelector),
      distinctUntilChanged()
    );
  }

  isProcessing(): Observable<boolean> {
    return this.store.pipe(select(isExploitationPlanProcessingSelector));
  }

  removeTaskFromStep(exploitationPlanId: string, parentId: string, taskId: string, taskPosition: number): void {
    this.store.dispatch(new RemoveExploitationPlanTaskAction(exploitationPlanId, parentId, taskId, taskPosition));
  }

  getExploitationPlanStepById(exploitationPlanId,exploitationPlanStepId: string) {
    return this.store.pipe(select(
        exploitationPlanStepByIDSelector(exploitationPlanId,exploitationPlanStepId)
      ),
    );
  }


  dispatchOrderTasks(
    exploitationPlanId: string,
    stepId: string,
    currentTasks: ExploitationPlanTask[],
    previousTasks: ExploitationPlanTask[]
  ) {
    this.store.dispatch(new OrderExploitationPlanTasksAction(
      exploitationPlanId,
      stepId,
      currentTasks,
      previousTasks
    ));
  }

}
