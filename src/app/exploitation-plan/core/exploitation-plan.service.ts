import { Injectable } from '@angular/core';

import { from as observableFrom, Observable, of as observableOf } from 'rxjs';
import { catchError, concatMap, map, mapTo, mergeMap, reduce, switchMap } from 'rxjs/operators';

import { environment } from '../../../environments/environment';
import { RemoteData } from '../../core/data/remote-data';
import { isEmpty, isNotEmpty, isNotNull, isNull } from '../../shared/empty.util';
import {
  getFinishedRemoteData,
  getFirstCompletedRemoteData,
  getFirstSucceededRemoteDataPayload
} from '../../core/shared/operators';
import { Item } from '../../core/shared/item.model';
import { ProjectDataService } from '../../core/project/project-data.service';
import { Metadata } from '../../core/shared/metadata.utils';
import { ItemDataService } from '../../core/data/item-data.service';
import { MetadataValue } from '../../core/shared/metadata.models';
import { ExploitationPlan } from './models/exploitation-plan.model';
import { ExploitationPlanStep } from './models/exploitation-plan-step.model';
import { ItemAuthorityRelationService } from '../../core/shared/item-authority-relation.service';
import { ExploitationPlanTask } from './models/exploitation-plan-task.model';
import { SubmissionFormModel } from '../../core/config/models/config-submission-form.model';
import { SubmissionFormsConfigService } from '../../core/config/submission-forms-config.service';
import { VocabularyOptions } from '../../core/submission/vocabularies/models/vocabulary-options.model';
import { VocabularyEntry } from '../../core/submission/vocabularies/models/vocabulary-entry.model';
import { VocabularyService } from '../../core/submission/vocabularies/vocabulary.service';
import { CollectionDataService } from '../../core/data/collection-data.service';

@Injectable()
export class ExploitationPlanService {

  constructor(
    protected collectionService: CollectionDataService,
    protected formConfigService: SubmissionFormsConfigService,
    protected itemAuthorityRelationService: ItemAuthorityRelationService,
    protected itemService: ItemDataService,
    protected projectService: ProjectDataService,
    protected vocabularyService: VocabularyService
  ) {
  }

  getExploitationPlanFromProjectId(projectId): Observable<RemoteData<Item>> {
    return this.projectService.getProjectItemByProjectCommunityId(projectId).pipe(
      getFirstSucceededRemoteDataPayload(),
      switchMap((projectItem: Item) => {
        const metadataValue = Metadata.first(projectItem.metadata, environment.exploitationPlan.exploitationPlanRelationMetadata);
        if (isNotEmpty(metadataValue) && isNotEmpty(metadataValue.authority)) {
          return this.itemService.findById(metadataValue.authority).pipe(
            getFirstCompletedRemoteData()
          );
        } else {
          throw(new Error('Link to project item is missing.'));
        }
      })
    );
  }

  getTaskTypeAuthorityName(stepType: string): string {
    return `exploitation_plan_${stepType}_task_type`;
  }

  getSearchTaskConfigName(stepType: string): string {
    return `exploitation_plan_${stepType}_task_type`;
  }

  getExploitationPlanStepFormConfig(stepType: string): Observable<SubmissionFormModel> {
    const formName = `exploitation_plan_${stepType}_form`;
    return this.formConfigService.findByName(formName).pipe(
      getFirstSucceededRemoteDataPayload()
    ) as Observable<SubmissionFormModel>;
  }

  getExploitationPlanTaskFormConfig(stepType: string): Observable<SubmissionFormModel> {
    const formName = `exploitation_plan_${stepType}_task_form`;
    return this.formConfigService.findByName(formName).pipe(
      getFirstSucceededRemoteDataPayload()
    ) as Observable<SubmissionFormModel>;
  }

  getExploitationPlanTaskFormHeader(stepType: string): string {
    return `exploitation_plan_${stepType}_task_form`;
  }

  getExploitationPlanTaskSearchHeader(stepType: string): string {
    return `exploitation-plan.${stepType}.task_search`;
  }

  getExploitationPlanTaskType(stepType: string, taskType: string): Observable<string> {
    const name = this.getTaskTypeAuthorityName(stepType);
    const vocabularyOptions: VocabularyOptions = new VocabularyOptions(name);

    return this.vocabularyService.getVocabularyEntryByValue(taskType, vocabularyOptions).pipe(
      map((entry: VocabularyEntry) => {
        if (isNull(entry)) {
          throw new Error(`No task type found for ${taskType}`);
        }

        return entry.display;
      }),
      catchError((error: Error) => observableOf(''))
    );
  }

  initExploitationPlan(item: Item): Observable<ExploitationPlan> {
    return this.initExploitationPlanSteps(item.id, item).pipe(
      map((steps: ExploitationPlanStep[]) => {
        return new ExploitationPlan(item.id, '', steps);
      })
    );
  }

  initExploitationPlanStep(parentId: string, stepItem: Item, tasks: ExploitationPlanTask[]): ExploitationPlanStep {
    const description = stepItem.firstMetadataValue('dc.description');

    return new ExploitationPlanStep(parentId, stepItem.id, stepItem.name, description, tasks);
  }

  initExploitationPlanSteps(exploitationPlanId: string, parentItem: Item): Observable<ExploitationPlanStep[]> {
    return observableFrom(Metadata.all(parentItem.metadata, environment.exploitationPlan.exploitationPlanStepRelationMetadata)).pipe(
      concatMap((step: MetadataValue) => this.itemService.findById(step.authority).pipe(
        getFirstSucceededRemoteDataPayload(),
        mergeMap((stepItem: Item) => this.initExploitationPlanTasksFromParentItem(exploitationPlanId, stepItem).pipe(
          map((tasks: ExploitationPlanTask[]) => this.initExploitationPlanStep(exploitationPlanId, stepItem, tasks))
        )),
      )),
      reduce((acc: any, value: any) => [...acc, value], [])
    );
  }

  initExploitationPlanTask(taskItem: Item, parentId?: string): ExploitationPlanTask {
    const type = taskItem.firstMetadataValue('dspace.entity.type');
    const description = taskItem.firstMetadataValue('dc.description');

    return new ExploitationPlanTask(taskItem.id, type, parentId, taskItem.name);
  }

  initExploitationPlanTasksFromParentItem(exploitationPlanId: string, parentItem: Item, buildLinks = true): Observable<ExploitationPlanTask[]> {
    const relatedTaskMetadata = Metadata.all(parentItem.metadata, environment.exploitationPlan.exploitationPlanTaskRelationMetadata);
    if (isEmpty(relatedTaskMetadata)) {
      return observableOf([]);
    } else {
      return observableFrom(Metadata.all(parentItem.metadata, environment.exploitationPlan.exploitationPlanTaskRelationMetadata)).pipe(
        concatMap((task: MetadataValue) => this.itemService.findById(task.authority).pipe(
          getFinishedRemoteData(),
          mergeMap((rd: RemoteData<Item>) => {
            if (rd.hasSucceeded) {
              return observableOf(this.initExploitationPlanTask(rd.payload, parentItem.id));
            } else {
              if (rd.statusCode === 404) {
                // NOTE if a task is not found probably it has been deleted without unlinking it from parent step, so unlink it
                return this.itemAuthorityRelationService.removeChildRelationFromParent(
                  parentItem.id,
                  task.value,
                  environment.exploitationPlan.exploitationPlanTaskRelationMetadata
                ).pipe(mapTo(null));
              } else {
                return observableOf(null);
              }
            }
          })
        )),
        reduce((acc: any, value: any) => {
          if (isNotNull(value)) {
            return [...acc, value];
          } else {
            return acc;
          }
        }, [])
      );
    }
  }

  updateExploitationPlanStep(newExploitationPlanStepItem: Item, oldExploitationPlanStep: ExploitationPlanStep): ExploitationPlanStep {
    const description = newExploitationPlanStepItem.firstMetadataValue('dc.description');

    return new ExploitationPlanStep(
      oldExploitationPlanStep.parentId,
      oldExploitationPlanStep.id,
      oldExploitationPlanStep.type,
      description,
      oldExploitationPlanStep.tasks
    );
  }
}
